# L08_SpringBoot_LoadAudio
REST API загрузки и получение файлов на сервер
Средства разработки: Java
Framework: Spring boot last version(3.2.4)
База данных: PostgreSQL или MySQL. Желательно PostgreSQL
# Функционал:
1.  Метод загрузки файла на сервер
•  В body-form-data принять файл (аудио файл любого формата mp3/oga/ogg/wav);
•  Сохранить файл в директорию на сервере;
•  Ответ сервера:
o  При успешном сохранении – вернуть StatusCode 200 и какое-нибудь 
поле об успешности (например, "status": true);
o  При ошибке – вернуть ошибку.
2.  Развернуть выбранную БД (где разворачивать БД - на ваше усмотрение)
•  Создать таблицу с дополнительной информацией по файлу, поля:
o  (PK)Id - smallserial/serial/bigserial;
o  Date - timestamp without time zone;
o  FileName - character varying, length 64;
o  Duration - integer;
•  Реализовать очистку строк старше 2 дней
o  По таймеру раз в час запускается фоновый процесс внутри приложения, 
который и выполняет очистку;
o  В случайном порядке реализовать имитацию исключения внутри 
данного процесса (в обязательных требованиях будет это 
использоваться).
3.  Метод записи дополнительной информации по файлу
•  В body-raw (json) принять информацию по файлу (Date|FileName|Duration);
•  Записать информацию в созданную ранее таблицу.
•  Ответ сервера:
o  При успешной записи – вернуть StatusCode 200, какое-нибудь поле об 
успешности (например, "status": true) и Id записи;
o  При ошибке – вернуть ошибку.
4.  Метод удаления файла и информации по нему
•  В параметре path принять Id файла(например files/{id}/deletefile);
•  Удалить файл из хранилища на сервере;
•  Удалить соответствующую строку из БД;
•  Ответ сервера:
o  При успешном сохранении – вернуть StatusCode 200 и какое-нибудь 
поле об успешности (например "status": true);
o  При ошибке – вернуть ошибку.
5.  Метод получения файла
•  В параметре path принять Id файла(например files/{id}/getfile);
•  Ответ сервера:
o  При успешном сохранении – вернуть StatusCode 200, какое-нибудь поле 
об успешности (например, "status": true) и файл на скачивание; 
o  При ошибке – вернуть ошибку.
6.  Метод получения информации по файлу
•  В параметре path принять Id файла (например, files/{id}/getfileinfo);
•  Ответ сервера:
o  При успешном сохранении – вернуть StatusCode 200, какое-нибудь поле 
об успешности (например, "status": true) и соответственно информация 
по файлу из БД;
o  При ошибке – вернуть ошибку.
# Обязательные требования:
•  Разбить задание на подзадачи;
•  Проект загрузить на github.com , а так же делать коммиты с описанием изменений;
•  Все ответы в формате JSON;
•  Все методы должны быть защищены статичным accessToken (можно прописать хардкодом, но словами рассказать, как нужно хранить такие вещи);
•  При проектировании API методов, нужно придерживаться правил именования ресурсов https://restapitutorial.ru/lessons/restfulresourcenaming/;
•  Обработка ошибок:
o  Ответ сервера при ошибке должен содержать поле об спешности (например, "status": false), символьный код ошибки (проще говоря краткое описание ошибки (например, "InvalidToken"), более подробное описание ошибки, а также подходящий StatusCode к той или иной ошибке;
o  При возникновении исключений и ошибок внутри приложения (фоновые 
процессы, обработчики и т.д.) - не дать приложению завершиться, а ошибки 
выводить в консоль.
•  Ограничения API методов:
o  Размер файла не должен превышать 64мб;
•  Для API должна быть сгенерирована документация, можно использовать Swagger. 
Другие варианты документации также приветствуются;
•  Проект должен быть развернут и работать в docker.
# В завершении:
•  Добавить в проект файл (например текстовый) с ходом работы над задачей:
o  Название/Описание подзадач;
o  Оценка на каждую подзадачу;
o  Фактически затраченное время;
o  Что было сделано в рамках каждой подзадачи (коротко, не нужно описывать каждый шаг);
•  Добавить в проект dockerfile;
•  Добавить в проект подробную инструкцию по развертыванию проекта на сервере с Docker. Так же указать, где нужно прописать строку доступа к БД;
•  Добавить в проект дамп схемы БД.
# Необязательные требования (будет плюсом):
•  Выполнять подзадачи в разных ветках и делать PullRequest's;
•  Реализовать простые автотесты на API (возвращают ли методы статус 200). Unit тесты писать не нужно; 
